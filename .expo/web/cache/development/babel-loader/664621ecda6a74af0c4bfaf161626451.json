{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as array from 'd3-array';\nimport * as scale from 'd3-scale';\nimport * as shape from 'd3-shape';\nimport PropTypes from 'prop-types';\nimport React, { PureComponent } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Svg from 'react-native-svg';\nimport Path from \"../animated-path\";\n\nvar BarChart = function (_PureComponent) {\n  _inherits(BarChart, _PureComponent);\n\n  var _super = _createSuper(BarChart);\n\n  function BarChart() {\n    var _this;\n\n    _classCallCheck(this, BarChart);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      width: 0,\n      height: 0\n    });\n\n    return _this;\n  }\n\n  _createClass(BarChart, [{\n    key: \"_onLayout\",\n    value: function _onLayout(event) {\n      var _event$nativeEvent$la = event.nativeEvent.layout,\n          height = _event$nativeEvent$la.height,\n          width = _event$nativeEvent$la.width;\n      this.setState({\n        height: height,\n        width: width\n      });\n    }\n  }, {\n    key: \"calcXScale\",\n    value: function calcXScale(domain) {\n      var data = this.props.data;\n      var _this$props = this.props,\n          horizontal = _this$props.horizontal,\n          _this$props$contentIn = _this$props.contentInset,\n          _this$props$contentIn2 = _this$props$contentIn.left,\n          left = _this$props$contentIn2 === void 0 ? 0 : _this$props$contentIn2,\n          _this$props$contentIn3 = _this$props$contentIn.right,\n          right = _this$props$contentIn3 === void 0 ? 0 : _this$props$contentIn3,\n          spacingInner = _this$props.spacingInner,\n          spacingOuter = _this$props.spacingOuter;\n      var width = this.state.width;\n\n      if (horizontal) {\n        return scale.scaleLinear().domain(domain).range([left, width - right]);\n      }\n\n      return scale.scaleBand().domain(data.map(function (_, index) {\n        return index;\n      })).range([left, width - right]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n    }\n  }, {\n    key: \"calcYScale\",\n    value: function calcYScale(domain) {\n      var data = this.props.data;\n      var _this$props2 = this.props,\n          horizontal = _this$props2.horizontal,\n          _this$props2$contentI = _this$props2.contentInset,\n          _this$props2$contentI2 = _this$props2$contentI.top,\n          top = _this$props2$contentI2 === void 0 ? 0 : _this$props2$contentI2,\n          _this$props2$contentI3 = _this$props2$contentI.bottom,\n          bottom = _this$props2$contentI3 === void 0 ? 0 : _this$props2$contentI3,\n          spacingInner = _this$props2.spacingInner,\n          spacingOuter = _this$props2.spacingOuter;\n      var height = this.state.height;\n\n      if (horizontal) {\n        return scale.scaleBand().domain(data.map(function (_, index) {\n          return index;\n        })).range([top, height - bottom]).paddingInner([spacingInner]).paddingOuter([spacingOuter]);\n      }\n\n      return scale.scaleLinear().domain(domain).range([height - bottom, top]);\n    }\n  }, {\n    key: \"calcAreas\",\n    value: function calcAreas(x, y, series) {\n      var _this$props3 = this.props,\n          horizontal = _this$props3.horizontal,\n          colors = _this$props3.colors,\n          keys = _this$props3.keys;\n\n      if (horizontal) {\n        return array.merge(series.map(function (serie, keyIndex) {\n          return serie.map(function (entry, entryIndex) {\n            var path = shape.area().x0(function (d) {\n              return x(d[0]);\n            }).x1(function (d) {\n              return x(d[1]);\n            }).y(function (d, _index) {\n              return _index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth();\n            }).defined(function (d) {\n              return !isNaN(d[0]) && !isNaN(d[1]);\n            })([entry, entry]);\n            return {\n              path: path,\n              color: colors[keyIndex],\n              key: keys[keyIndex]\n            };\n          });\n        }));\n      }\n\n      return array.merge(series.map(function (serie, keyIndex) {\n        return serie.map(function (entry, entryIndex) {\n          var path = shape.area().y0(function (d) {\n            return y(d[0]);\n          }).y1(function (d) {\n            return y(d[1]);\n          }).x(function (d, _index) {\n            return _index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth();\n          }).defined(function (d) {\n            return !isNaN(d[0]) && !isNaN(d[1]);\n          })([entry, entry]);\n          return {\n            path: path,\n            color: colors[keyIndex],\n            key: keys[keyIndex]\n          };\n        });\n      }));\n    }\n  }, {\n    key: \"calcExtent\",\n    value: function calcExtent(values) {\n      var _this$props4 = this.props,\n          gridMax = _this$props4.gridMax,\n          gridMin = _this$props4.gridMin;\n      return array.extent([].concat(_toConsumableArray(values), [gridMin, gridMax]));\n    }\n  }, {\n    key: \"calcIndexes\",\n    value: function calcIndexes(values) {\n      return values.map(function (_, index) {\n        return index;\n      });\n    }\n  }, {\n    key: \"getSeries\",\n    value: function getSeries() {\n      var _this$props5 = this.props,\n          data = _this$props5.data,\n          keys = _this$props5.keys,\n          offset = _this$props5.offset,\n          order = _this$props5.order,\n          valueAccessor = _this$props5.valueAccessor;\n      return shape.stack().keys(keys).value(function (item, key) {\n        return valueAccessor({\n          item: item,\n          key: key\n        });\n      }).order(order).offset(offset)(data);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props6 = this.props,\n          data = _this$props6.data,\n          animate = _this$props6.animate,\n          animationDuration = _this$props6.animationDuration,\n          style = _this$props6.style,\n          numberOfTicks = _this$props6.numberOfTicks,\n          children = _this$props6.children,\n          horizontal = _this$props6.horizontal;\n      var _this$state = this.state,\n          height = _this$state.height,\n          width = _this$state.width;\n\n      if (data.length === 0) {\n        return React.createElement(View, {\n          style: style\n        });\n      }\n\n      var series = this.getSeries();\n      var values = array.merge(array.merge(series));\n      var indexes = this.calcIndexes(values);\n      var extent = this.calcExtent(values);\n      var ticks = array.ticks(extent[0], extent[1], numberOfTicks);\n      var xDomain = horizontal ? extent : indexes;\n      var yDomain = horizontal ? indexes : extent;\n      var x = this.calcXScale(xDomain);\n      var y = this.calcYScale(yDomain);\n      var bandwidth = horizontal ? y.bandwidth() : x.bandwidth();\n      var areas = this.calcAreas(x, y, series);\n      var extraProps = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        ticks: ticks,\n        data: data,\n        bandwidth: bandwidth\n      };\n      return React.createElement(View, {\n        style: style\n      }, React.createElement(View, {\n        style: {\n          flex: 1\n        },\n        onLayout: function onLayout(event) {\n          return _this2._onLayout(event);\n        }\n      }, height > 0 && width > 0 && React.createElement(Svg, {\n        style: {\n          height: height,\n          width: width\n        }\n      }, React.Children.map(children, function (child) {\n        if (child && child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }), areas.map(function (bar, index) {\n        var keyIndex = index % data.length;\n        var key = \"\".concat(keyIndex, \"-\").concat(bar.key);\n        var svg = data[keyIndex][bar.key].svg;\n        return React.createElement(Path, _extends({\n          key: key,\n          fill: bar.color\n        }, svg, {\n          d: bar.path,\n          animate: animate,\n          animationDuration: animationDuration\n        }));\n      }), React.Children.map(children, function (child) {\n        if (child && !child.props.belowChart) {\n          return React.cloneElement(child, extraProps);\n        }\n\n        return null;\n      }))));\n    }\n  }], [{\n    key: \"extractDataPoints\",\n    value: function extractDataPoints(data, keys) {\n      var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shape.stackOrderNone;\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : shape.stackOffsetNone;\n      var series = shape.stack().keys(keys).order(order).offset(offset)(data);\n      return array.merge(array.merge(series));\n    }\n  }]);\n\n  return BarChart;\n}(PureComponent);\n\nBarChart.propTypes = {\n  data: PropTypes.arrayOf(PropTypes.object),\n  keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n  offset: PropTypes.func,\n  order: PropTypes.func,\n  style: PropTypes.any,\n  spacingInner: PropTypes.number,\n  spacingOuter: PropTypes.number,\n  animate: PropTypes.bool,\n  animationDuration: PropTypes.number,\n  contentInset: PropTypes.shape({\n    top: PropTypes.number,\n    left: PropTypes.number,\n    right: PropTypes.number,\n    bottom: PropTypes.number\n  }),\n  gridMin: PropTypes.number,\n  gridMax: PropTypes.number,\n  valueAccessor: PropTypes.func\n};\nBarChart.defaultProps = {\n  spacingInner: 0.05,\n  spacingOuter: 0.05,\n  offset: shape.stackOffsetNone,\n  order: shape.stackOrderNone,\n  width: 100,\n  height: 100,\n  showZeroAxis: true,\n  contentInset: {},\n  numberOfTicks: 10,\n  showGrid: true,\n  valueAccessor: function valueAccessor(_ref) {\n    var item = _ref.item,\n        key = _ref.key;\n    return item[key];\n  }\n};\nexport default BarChart;","map":{"version":3,"sources":["stacked-bar-chart.js"],"names":["order","shape","offset","series","array","width","height","_onLayout","nativeEvent","layout","calcXScale","data","contentInset","left","right","spacingOuter","scale","calcYScale","top","bottom","calcAreas","keys","path","d","x","_index","y","isNaN","color","colors","key","calcExtent","gridMin","calcIndexes","values","getSeries","valueAccessor","item","render","horizontal","style","indexes","extent","ticks","xDomain","yDomain","bandwidth","areas","extraProps","flex","event","child","React","keyIndex","index","bar","svg","animationDuration","BarChart","PropTypes","spacingInner","animate","number","gridMax","func","showZeroAxis","numberOfTicks","showGrid"],"mappings":"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","sourcesContent":["import * as array from 'd3-array'\nimport * as scale from 'd3-scale'\nimport * as shape from 'd3-shape'\nimport PropTypes from 'prop-types'\nimport React, { PureComponent } from 'react'\nimport { View } from 'react-native'\nimport Svg from 'react-native-svg'\nimport Path from '../animated-path'\n\nclass BarChart extends PureComponent {\n    static extractDataPoints(data, keys, order = shape.stackOrderNone, offset = shape.stackOffsetNone) {\n        const series = shape\n            .stack()\n            .keys(keys)\n            .order(order)\n            .offset(offset)(data)\n\n        //double merge arrays to extract just the values\n        return array.merge(array.merge(series))\n    }\n\n    state = {\n        width: 0,\n        height: 0,\n    }\n\n    _onLayout(event) {\n        const {\n            nativeEvent: {\n                layout: { height, width },\n            },\n        } = event\n        this.setState({ height, width })\n    }\n\n    calcXScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { left = 0, right = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { width } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleLinear()\n                .domain(domain)\n                .range([left, width - right])\n        }\n\n        // use index as domain identifier instead of value since\n        // domain must be same length as number of bars\n        // same value can occur at several places in data\n        return scale\n            .scaleBand()\n            .domain(data.map((_, index) => index))\n            .range([left, width - right])\n            .paddingInner([spacingInner])\n            .paddingOuter([spacingOuter])\n    }\n\n    calcYScale(domain) {\n        const { data } = this.props\n\n        const {\n            horizontal,\n            contentInset: { top = 0, bottom = 0 },\n            spacingInner,\n            spacingOuter,\n        } = this.props\n\n        const { height } = this.state\n\n        if (horizontal) {\n            return scale\n                .scaleBand()\n                .domain(data.map((_, index) => index))\n                .range([top, height - bottom])\n                .paddingInner([spacingInner])\n                .paddingOuter([spacingOuter])\n        }\n\n        return scale\n            .scaleLinear()\n            .domain(domain)\n            .range([height - bottom, top])\n    }\n\n    calcAreas(x, y, series) {\n        const { horizontal, colors, keys } = this.props\n\n        if (horizontal) {\n            return array.merge(\n                series.map((serie, keyIndex) => {\n                    return serie.map((entry, entryIndex) => {\n                        const path = shape\n                            .area()\n                            .x0((d) => x(d[0]))\n                            .x1((d) => x(d[1]))\n                            .y((d, _index) => (_index === 0 ? y(entryIndex) : y(entryIndex) + y.bandwidth()))\n                            .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                        return {\n                            path,\n                            color: colors[keyIndex],\n                            key: keys[keyIndex],\n                        }\n                    })\n                })\n            )\n        }\n\n        return array.merge(\n            series.map((serie, keyIndex) => {\n                return serie.map((entry, entryIndex) => {\n                    const path = shape\n                        .area()\n                        .y0((d) => y(d[0]))\n                        .y1((d) => y(d[1]))\n                        .x((d, _index) => (_index === 0 ? x(entryIndex) : x(entryIndex) + x.bandwidth()))\n                        .defined((d) => !isNaN(d[0]) && !isNaN(d[1]))([entry, entry])\n\n                    return {\n                        path,\n                        color: colors[keyIndex],\n                        key: keys[keyIndex],\n                    }\n                })\n            })\n        )\n    }\n\n    calcExtent(values) {\n        const { gridMax, gridMin } = this.props\n\n        return array.extent([...values, gridMin, gridMax])\n    }\n\n    calcIndexes(values) {\n        return values.map((_, index) => index)\n    }\n\n    getSeries() {\n        const { data, keys, offset, order, valueAccessor } = this.props\n\n        return shape\n            .stack()\n            .keys(keys)\n            .value((item, key) => valueAccessor({ item, key }))\n            .order(order)\n            .offset(offset)(data)\n    }\n\n    render() {\n        const { data, animate, animationDuration, style, numberOfTicks, children, horizontal } = this.props\n\n        const { height, width } = this.state\n\n        if (data.length === 0) {\n            return <View style={style} />\n        }\n\n        const series = this.getSeries()\n\n        //double merge arrays to extract just the values\n        const values = array.merge(array.merge(series))\n        const indexes = this.calcIndexes(values)\n\n        const extent = this.calcExtent(values)\n        const ticks = array.ticks(extent[0], extent[1], numberOfTicks)\n\n        const xDomain = horizontal ? extent : indexes\n        const yDomain = horizontal ? indexes : extent\n\n        const x = this.calcXScale(xDomain)\n        const y = this.calcYScale(yDomain)\n\n        const bandwidth = horizontal ? y.bandwidth() : x.bandwidth()\n\n        const areas = this.calcAreas(x, y, series)\n\n        const extraProps = {\n            x,\n            y,\n            width,\n            height,\n            ticks,\n            data,\n            bandwidth,\n        }\n\n        return (\n            <View style={style}>\n                <View style={{ flex: 1 }} onLayout={(event) => this._onLayout(event)}>\n                    {height > 0 && width > 0 && (\n                        <Svg style={{ height, width }}>\n                            {React.Children.map(children, (child) => {\n                                if (child && child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                            {areas.map((bar, index) => {\n                                const keyIndex = index % data.length\n                                const key = `${keyIndex}-${bar.key}`\n                                const { svg } = data[keyIndex][bar.key]\n\n                                return (\n                                    <Path\n                                        key={key}\n                                        fill={bar.color}\n                                        {...svg}\n                                        d={bar.path}\n                                        animate={animate}\n                                        animationDuration={animationDuration}\n                                    />\n                                )\n                            })}\n                            {React.Children.map(children, (child) => {\n                                if (child && !child.props.belowChart) {\n                                    return React.cloneElement(child, extraProps)\n                                }\n                                return null\n                            })}\n                        </Svg>\n                    )}\n                </View>\n            </View>\n        )\n    }\n}\n\nBarChart.propTypes = {\n    data: PropTypes.arrayOf(PropTypes.object),\n    keys: PropTypes.arrayOf(PropTypes.string).isRequired,\n    colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n    offset: PropTypes.func,\n    order: PropTypes.func,\n    style: PropTypes.any,\n    spacingInner: PropTypes.number,\n    spacingOuter: PropTypes.number,\n    animate: PropTypes.bool,\n    animationDuration: PropTypes.number,\n    contentInset: PropTypes.shape({\n        top: PropTypes.number,\n        left: PropTypes.number,\n        right: PropTypes.number,\n        bottom: PropTypes.number,\n    }),\n    gridMin: PropTypes.number,\n    gridMax: PropTypes.number,\n    valueAccessor: PropTypes.func,\n}\n\nBarChart.defaultProps = {\n    spacingInner: 0.05,\n    spacingOuter: 0.05,\n    offset: shape.stackOffsetNone,\n    order: shape.stackOrderNone,\n    width: 100,\n    height: 100,\n    showZeroAxis: true,\n    contentInset: {},\n    numberOfTicks: 10,\n    showGrid: true,\n    valueAccessor: ({ item, key }) => item[key],\n}\n\nexport default BarChart\n"]},"metadata":{},"sourceType":"module"}