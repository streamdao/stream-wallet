{"ast":null,"code":"'use strict';\n\nvar _global$HermesInterna, _global$HermesInterna2;\n\nvar _require = require(\"../Utilities/PolyfillFunctions\"),\n    polyfillGlobal = _require.polyfillGlobal;\n\nvar _require2 = require(\"../Utilities/FeatureDetection\"),\n    isNativeFunction = _require2.isNativeFunction;\n\nif (__DEV__) {\n  if (typeof global.Promise !== 'function') {\n    console.error('Promise should exist before setting up timers.');\n  }\n}\n\nvar hasHermesPromiseQueuedToJSVM = ((_global$HermesInterna = global.HermesInternal) == null ? void 0 : _global$HermesInterna.hasPromise == null ? void 0 : _global$HermesInterna.hasPromise()) === true && ((_global$HermesInterna2 = global.HermesInternal) == null ? void 0 : _global$HermesInterna2.useEngineQueue == null ? void 0 : _global$HermesInterna2.useEngineQueue()) === true;\nvar hasNativePromise = isNativeFunction(Promise);\nvar hasPromiseQueuedToJSVM = hasNativePromise || hasHermesPromiseQueuedToJSVM;\n\nif (global.RN$Bridgeless !== true) {\n  var defineLazyTimer = function defineLazyTimer(name) {\n    polyfillGlobal(name, function () {\n      return require(\"./Timers/JSTimers\")[name];\n    });\n  };\n\n  defineLazyTimer('setTimeout');\n  defineLazyTimer('clearTimeout');\n  defineLazyTimer('setInterval');\n  defineLazyTimer('clearInterval');\n  defineLazyTimer('requestAnimationFrame');\n  defineLazyTimer('cancelAnimationFrame');\n  defineLazyTimer('requestIdleCallback');\n  defineLazyTimer('cancelIdleCallback');\n}\n\nif (hasPromiseQueuedToJSVM) {\n  polyfillGlobal('setImmediate', function () {\n    return require(\"./Timers/immediateShim\").setImmediate;\n  });\n  polyfillGlobal('clearImmediate', function () {\n    return require(\"./Timers/immediateShim\").clearImmediate;\n  });\n} else {\n  if (global.RN$Bridgeless !== true) {\n    polyfillGlobal('setImmediate', function () {\n      return require(\"./Timers/JSTimers\").queueReactNativeMicrotask;\n    });\n    polyfillGlobal('clearImmediate', function () {\n      return require(\"./Timers/JSTimers\").clearReactNativeMicrotask;\n    });\n  }\n}\n\nif (hasHermesPromiseQueuedToJSVM) {\n  polyfillGlobal('queueMicrotask', function () {\n    var _global$HermesInterna3;\n\n    return (_global$HermesInterna3 = global.HermesInternal) == null ? void 0 : _global$HermesInterna3.enqueueJob;\n  });\n} else {\n  polyfillGlobal('queueMicrotask', function () {\n    return require(\"./Timers/queueMicrotask.js\").default;\n  });\n}","map":{"version":3,"sources":["/workspace/stream-pay/node_modules/react-native/Libraries/Core/setUpTimers.js"],"names":["require","polyfillGlobal","isNativeFunction","__DEV__","global","Promise","console","error","hasHermesPromiseQueuedToJSVM","HermesInternal","hasPromise","useEngineQueue","hasNativePromise","hasPromiseQueuedToJSVM","RN$Bridgeless","defineLazyTimer","name","setImmediate","clearImmediate","queueReactNativeMicrotask","clearReactNativeMicrotask","enqueueJob","default"],"mappings":"AAUA;;;;AAEA,eAAyBA,OAAO,kCAAhC;AAAA,IAAOC,cAAP,YAAOA,cAAP;;AACA,gBAA2BD,OAAO,iCAAlC;AAAA,IAAOE,gBAAP,aAAOA,gBAAP;;AAEA,IAAIC,OAAJ,EAAa;AACX,MAAI,OAAOC,MAAM,CAACC,OAAd,KAA0B,UAA9B,EAA0C;AACxCC,IAAAA,OAAO,CAACC,KAAR,CAAc,gDAAd;AACD;AACF;;AAGD,IAAMC,4BAA4B,GAChC,0BAAAJ,MAAM,CAACK,cAAP,2CAAuBC,UAAvB,0CAAuBA,UAAvB,QAA0C,IAA1C,IACA,2BAAAN,MAAM,CAACK,cAAP,4CAAuBE,cAAvB,2CAAuBA,cAAvB,QAA8C,IAFhD;AAIA,IAAMC,gBAAgB,GAAGV,gBAAgB,CAACG,OAAD,CAAzC;AACA,IAAMQ,sBAAsB,GAAGD,gBAAgB,IAAIJ,4BAAnD;;AAGA,IAAIJ,MAAM,CAACU,aAAP,KAAyB,IAA7B,EAAmC;AAKjC,MAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,IAAI,EAAI;AAC9Bf,IAAAA,cAAc,CAACe,IAAD,EAAO;AAAA,aAAMhB,OAAO,qBAAP,CAA6BgB,IAA7B,CAAN;AAAA,KAAP,CAAd;AACD,GAFD;;AAGAD,EAAAA,eAAe,CAAC,YAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,cAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,aAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,eAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,uBAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,sBAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,qBAAD,CAAf;AACAA,EAAAA,eAAe,CAAC,oBAAD,CAAf;AACD;;AAMD,IAAIF,sBAAJ,EAA4B;AAG1BZ,EAAAA,cAAc,CACZ,cADY,EAEZ;AAAA,WAAMD,OAAO,0BAAP,CAAkCiB,YAAxC;AAAA,GAFY,CAAd;AAIAhB,EAAAA,cAAc,CACZ,gBADY,EAEZ;AAAA,WAAMD,OAAO,0BAAP,CAAkCkB,cAAxC;AAAA,GAFY,CAAd;AAID,CAXD,MAWO;AAIL,MAAId,MAAM,CAACU,aAAP,KAAyB,IAA7B,EAAmC;AACjCb,IAAAA,cAAc,CACZ,cADY,EAEZ;AAAA,aAAMD,OAAO,qBAAP,CAA6BmB,yBAAnC;AAAA,KAFY,CAAd;AAIAlB,IAAAA,cAAc,CACZ,gBADY,EAEZ;AAAA,aAAMD,OAAO,qBAAP,CAA6BoB,yBAAnC;AAAA,KAFY,CAAd;AAID;AACF;;AAMD,IAAIZ,4BAAJ,EAAkC;AAEhCP,EAAAA,cAAc,CAAC,gBAAD,EAAmB;AAAA;;AAAA,qCAAMG,MAAM,CAACK,cAAb,qBAAM,uBAAuBY,UAA7B;AAAA,GAAnB,CAAd;AACD,CAHD,MAGO;AAELpB,EAAAA,cAAc,CACZ,gBADY,EAEZ;AAAA,WAAMD,OAAO,8BAAP,CAAsCsB,OAA5C;AAAA,GAFY,CAAd;AAID","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nconst {polyfillGlobal} = require('../Utilities/PolyfillFunctions');\nconst {isNativeFunction} = require('../Utilities/FeatureDetection');\n\nif (__DEV__) {\n  if (typeof global.Promise !== 'function') {\n    console.error('Promise should exist before setting up timers.');\n  }\n}\n\n// Currently, Hermes `Promise` is implemented via Internal Bytecode.\nconst hasHermesPromiseQueuedToJSVM =\n  global.HermesInternal?.hasPromise?.() === true &&\n  global.HermesInternal?.useEngineQueue?.() === true;\n\nconst hasNativePromise = isNativeFunction(Promise);\nconst hasPromiseQueuedToJSVM = hasNativePromise || hasHermesPromiseQueuedToJSVM;\n\n// In bridgeless mode, timers are host functions installed from cpp.\nif (global.RN$Bridgeless !== true) {\n  /**\n   * Set up timers.\n   * You can use this module directly, or just require InitializeCore.\n   */\n  const defineLazyTimer = name => {\n    polyfillGlobal(name, () => require('./Timers/JSTimers')[name]);\n  };\n  defineLazyTimer('setTimeout');\n  defineLazyTimer('clearTimeout');\n  defineLazyTimer('setInterval');\n  defineLazyTimer('clearInterval');\n  defineLazyTimer('requestAnimationFrame');\n  defineLazyTimer('cancelAnimationFrame');\n  defineLazyTimer('requestIdleCallback');\n  defineLazyTimer('cancelIdleCallback');\n}\n\n/**\n * Set up immediate APIs, which is required to use the same microtask queue\n * as the Promise.\n */\nif (hasPromiseQueuedToJSVM) {\n  // When promise queues to the JSVM microtasks queue, we shim the immedaite\n  // APIs via `queueMicrotask` to maintain the backward compatibility.\n  polyfillGlobal(\n    'setImmediate',\n    () => require('./Timers/immediateShim').setImmediate,\n  );\n  polyfillGlobal(\n    'clearImmediate',\n    () => require('./Timers/immediateShim').clearImmediate,\n  );\n} else {\n  // When promise was polyfilled hence is queued to the RN microtask queue,\n  // we polyfill the immediate APIs as aliases to the ReactNativeMicrotask APIs.\n  // Note that in bridgeless mode, immediate APIs are installed from cpp.\n  if (global.RN$Bridgeless !== true) {\n    polyfillGlobal(\n      'setImmediate',\n      () => require('./Timers/JSTimers').queueReactNativeMicrotask,\n    );\n    polyfillGlobal(\n      'clearImmediate',\n      () => require('./Timers/JSTimers').clearReactNativeMicrotask,\n    );\n  }\n}\n\n/**\n * Set up the microtask queueing API, which is required to use the same\n * microtask queue as the Promise.\n */\nif (hasHermesPromiseQueuedToJSVM) {\n  // Fast path for Hermes.\n  polyfillGlobal('queueMicrotask', () => global.HermesInternal?.enqueueJob);\n} else {\n  // Polyfill it with promise (regardless it's polyfiled or native) otherwise.\n  polyfillGlobal(\n    'queueMicrotask',\n    () => require('./Timers/queueMicrotask.js').default,\n  );\n}\n"]},"metadata":{},"sourceType":"script"}